/*
Create a SystemVerilog module for a network packet scheduler that uses an FSM to manage packet queuing and transmission based on priority and type. The FSM should handle different network conditions dynamically.

Specifications:

Multiple queues for different types of traffic (e.g., VoIP, streaming, data).
Dynamic adjustment based on bandwidth availability.
Error handling for packet loss or corruption.
States to manage congestion and optimize throughput.
Prioritization mechanism for critical data packets.
*/
//WIP - ERROR, CONGESTION is remaining 

module PacketScheduler(
    input logic clk,
    input logic reset,
    input logic[1:0] stream_type,  // 2-bit signal for data type
    input logic[7:0] data_in,      // Incoming data byte
  output logic[127:0] data_out,    // Outgoing data packet
    output logic valid_out         // Signal to indicate data out is valid
);

    typedef enum logic[2:0] {
        IDLE = 3'b000,
        VOIP = 3'b001,
        STREAMING = 3'b010,
        DATA = 3'b011
        //ERROR = 3'b100,
        //CONGESTION = 3'b101
    } state_t;

    state_t CSTATE, NSTATE;

    // Data buffers for accumulation
    logic[63:0] voip_buffer;
    logic[127:0] data_buffer;
  logic [7:0] r_byte_count;
  logic w_voip_done,w_data_done;

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            CSTATE <= IDLE;
            r_byte_count <= 0;
            //voip_buffer <= 0;
            //data_buffer <= 0;
        end else begin
            CSTATE <= NSTATE;
          case(CSTATE)
            IDLE: r_byte_count <= '0;
            STREAMING: r_byte_count <= '0;
            VOIP: begin 
              r_byte_count <= w_voip_done ? '0 : r_byte_count + 1;
            end 
            DATA: begin 
              r_byte_count <= w_data_done ? '0 : r_byte_count + 1;
            end 
          endcase
        end
    end

    always_comb begin
        valid_out = 0;
        data_out = 8'b0;
        voip_buffer = '0;
        data_buffer = '0;
      case (CSTATE)
            IDLE: begin
                case (stream_type)
                    2'b00: NSTATE = VOIP;
                    2'b01: NSTATE = STREAMING;
                    2'b10: NSTATE = DATA;
                    //default: NSTATE = ERROR;
                endcase
            end
            VOIP: begin
              voip_buffer[r_byte_count*8 +: 8] = data_in;
                //byte_count++;
              if (r_byte_count == 7) begin
                    data_out = voip_buffer; // Send all at once
                    valid_out = 1;
                    //r_byte_count = 0;
                    NSTATE = IDLE;
                end
            end
            STREAMING: begin
                data_out = data_in; // Send byte by byte
                valid_out = 1;
                NSTATE = IDLE;
            end
            DATA: begin
              data_buffer[r_byte_count*8 +: 8] = data_in;
                //byte_count++;
              if (r_byte_count == 15) begin
                    data_out = data_buffer; // Send all at once
                    valid_out = 1;
                    //r_byte_count = 0;
                    NSTATE = IDLE;
                end
            end
          /*
            ERROR: begin
                // Handle error
                next_state = IDLE;
            end
            CONGESTION: begin
                // Adjust sending logic based on congestion
                next_state = IDLE;
            end
            */
        endcase
    end
  
  assign w_voip_done = (CSTATE == VOIP) && (r_byte_count == 8'd7);
  assign w_data_done = (CSTATE == DATA) && (r_byte_count == 8'd15);

endmodule
